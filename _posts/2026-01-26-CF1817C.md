---
layout: post
title: "CF1817C Similar Polynomials 题解"
tags: Codeforces 题解
---

$F(x)$ 差分 $n-1$ 次后的结果是 $F^{(n-1)}(x)$，$F(x+d)$ 差分 $n-1$ 次后的结果是 $F^{(n-1)}(x+d)$，而 $F^{(n-1)}(x)$ 和 $F^{(n-1)}(x+d)$ 都是一次函数，不妨令 $F^{(n-1)}=kx+b$，那么

$$
F^{(n-1)}(0)=b,F^{(n-1)}(1)=k+b,\\
F^{(n-1)}(d)=kd+b
$$

回忆一下 $k$ 阶差分公式：

$$
\Delta^kf(x)=\sum_{i=0}^k\binom ki(-1)^{k-i}f(x+i)
$$

```cpp
#include<bits/stdc++.h>
#define siz(x) int((x).size())
#define all(x) std::begin(x),std::end(x)
#define fi first
#define se second
using namespace std;
using unt=unsigned;
using loli=long long;
using lolu=unsigned long long;
using pii=pair<int,int>;
mt19937_64 rng(random_device{}());
constexpr int N=2.5e6+7,P=1e9+7;
struct mint{
	int d;
	mint()=default;
	mint(int x):d(x){}
	friend std::istream&operator>>(std::istream&x,mint&y){return x>>y.d;}
	friend std::ostream&operator<<(std::ostream&x,mint y){return x<<y.d;}
	friend mint operator+(mint x,mint y){return (x.d+=y.d)<P?x.d:x.d-P;}
	mint&operator+=(mint z){return (d+=z.d)<P?d:d-=P,*this;}
	friend mint operator-(mint x,mint y){return (x.d-=y.d)<0?x.d+P:x.d;}
	mint&operator-=(mint z){return (d-=z.d)<0?d+=P:d,*this;}
	friend mint operator*(mint x,mint y){return int(1ll*x.d*y.d%P);}
	mint&operator*=(mint z){return d=int(1ll*d*z.d%P),*this;}
	static mint qpow(int x,int y=P-2){int z=1;for(;y;y>>=1,x=int(1ll*x*x%P))if(y&1)z=int(1ll*x*z%P);return z;}
	friend mint operator/(mint x,mint y){return x*=qpow(y.d);}
	mint&operator/=(mint z){return (*this)*=qpow(z.d);}
	friend mint operator^(mint x,mint y){return qpow(x.d,y.d);}
	mint&operator^=(mint z){return *this=qpow(d,z.d);}
	mint operator()(mint z)const{return qpow(d,z.d);}
	mint&operator[](mint z){return *this=qpow(d,z.d);}
	mint inv()const{return qpow(d);}
	mint pow(mint z)const{return qpow(d,z.d);}
	int operator+()const{return d;}
	mint operator-()const{return d?P-d:0;}
	int operator~()const{return ~d;}
};
mint operator""_m(lolu x){return mint(int(x%P));}
mint fac[N],inv[N];
int n,a[N],b[N];
mint Bi(int x,int y){
	if(x<0||y<0||x<y)return 0;
	return fac[x]*inv[y]*inv[x-y];
}
mint mm1(int x){return x&1?P-1:1;}
signed main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	ios::sync_with_stdio(false);cin.tie(nullptr);
	fac[0]=inv[0]=1;
	for(int i=1;i<N;i++)fac[i]=fac[i-1]*i;
	inv[N-1]=fac[N-1].inv();
	for(int i=N-2;i;i--)inv[i]=inv[i+1]*(i+1);
	cin>>n;
	for(int i=0;i<=n;i++)cin>>a[i];
	for(int i=0;i<=n;i++)cin>>b[i];
	mint a0=0,a1=0,b0=0,b1=0;
	int k=n-1;
	for(int i=0;i<=k;i++)a0+=Bi(k,i)*mm1(k-i)*a[i];
	for(int i=0;i<=k;i++)a1+=Bi(k,i)*mm1(k-i)*a[i+1];
	for(int i=0;i<=k;i++)b0+=Bi(k,i)*mm1(k-i)*b[i];
	for(int i=0;i<=k;i++)b1+=Bi(k,i)*mm1(k-i)*b[i+1];
	cout<<(b0-a0)/(a1-a0);
	return 0;
}
```